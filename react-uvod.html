<!doctype html><html data-reactid=".cjehldcdfk" data-react-checksum="-1265030824"><head data-reactid=".cjehldcdfk.0"><meta charset="utf-8" data-reactid=".cjehldcdfk.0.0"><title data-reactid=".cjehldcdfk.0.1">DžejEs - JavaScript pro web</title><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" data-reactid=".cjehldcdfk.0.2"><link rel="stylesheet" type="text/css" href="main-c4e5492e99c449d90c84.css?v=1.0.0" data-reactid=".cjehldcdfk.0.3"><link rel="icon" type="image/png" href="images/favicon-4b52c7e9cc28fdb9378fd1542994a946.png" data-reactid=".cjehldcdfk.0.4"><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" data-reactid=".cjehldcdfk.0.5"><base target="_blank" data-reactid=".cjehldcdfk.0.6"></head><body data-reactid=".cjehldcdfk.1"><div data-reactid=".cjehldcdfk.1.0"><header class="Header" data-reactid=".cjehldcdfk.1.0.0"><div class="NavBar" data-reactid=".cjehldcdfk.1.0.0.0"><div class="NavBar-container" data-reactid=".cjehldcdfk.1.0.0.0.0"><div class="NavBar-item" data-reactid=".cjehldcdfk.1.0.0.0.0.0"><a class="NavBar-link" href="/" target="_self" data-reactid=".cjehldcdfk.1.0.0.0.0.0.0">Úvod</a><a class="NavBar-link" href="https://twitter.com/vmiksu" data-reactid=".cjehldcdfk.1.0.0.0.0.0.1">Twitter</a><a class="NavBar-link" href="https://github.com/tajo/javascript" data-reactid=".cjehldcdfk.1.0.0.0.0.0.2">GitHub</a><a class="NavBar-link" href="/feed.xml" data-reactid=".cjehldcdfk.1.0.0.0.0.0.3">RSS</a></div></div></div></header><div class="PageBody" data-reactid=".cjehldcdfk.1.0.1"><div class="PageBody-container" data-reactid=".cjehldcdfk.1.0.1.0"><div style="width:100%;" data-reactid=".cjehldcdfk.1.0.1.0.0"><div style="width:100%;" data-reactid=".cjehldcdfk.1.0.1.0.0.$0"><h1>React - Úvod<a id="react-vod">&nbsp;</a></h1><p><strong>React je JavaScriptová knihovna pro vytváření webových komponent.</strong> V pomyslném MVC představuje &quot;V&quot; neboli view vrstvu a dal by se tak přirovnat například Latte v Nette. React je však daleko více. Přináší totiž zásadní změnu paradigmatu. S Reactem už nepíšeme kód, který něco mění, ale kód, který popisuje, jak má vypadat výsledek, což je řádově snažší úloha. Dvojnásob to pak platí, pokud tím výsledkem je &quot;těžká váha&quot; v podobě DOMu.</p>
<p class="pic-container" style="max-width:300px">
  <img src="images/logo-37fe8322b169ddbdeabf75930e886ac6.png" class="pic" title="JS knihoven není nikdy dost" />
</p>


<h2>Trocha historie<a id="trocha-historie">&nbsp;</a></h2><p><strong>React spatřil světlo světa v květnu 2013</strong>. Opensourcoval ho Facebook, který ho už několik let před tím sám interně používal a vylepšoval. Prvotní vydání se však dočkalo velkého výsměchu. Odezva byla dokonce tak špatná, že Facebook chvíli uvažoval i o jeho stáhnutí. Terčem kritiky se stalo především míchání &quot;HTML a programování&quot;. Podobné obavy nedávno vyjádřili i někteří <a href="https://twitter.com/geekovo/status/604710448131391490">prominentní čeští webaři</a>. Postupně se však ukázalo, že došlo k pouze nepochopení základního konceptu a nejen FE vývojáři si začli rychle osvojovat a užívat nové fundamenty, které React přinesl.</p>
<p><strong>K dnešnímu dni</strong> (červenec 2015) <strong>má 4800 commitů, 25 000 stargazerů a 444 contributorů a je tak jedním z nejoblíbenějších a nejaktivnějších repozitářů na GitHubu</strong>. Facebook během této doby uvolnil i další JS projekty jako <a href="https://facebook.github.io/react-native/">React Native</a> (React pro iOS a blíží se i vydání Android verze), <a href="https://facebook.github.io/immutable-js/">Immutable.js</a> (immutable kolekce) či <a href="https://facebook.github.io/flux/">Flux</a> (M a C doplňující React v pomyslném MVC).</p>
<p>Horkou novinkou je pak <a href="http://facebook.github.io/graphql/">GraphQL</a>, což je dotazovací jazyk, kterým v komponentách popíšete, jaká data ze serveru potřebují. V srpnu 2015 pak vyjde <a href="https://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html">Relay</a>, který GraphQL bude umět na straně webu zpracovat a rýsuje se nám tak zajímavé řešení pro datovou komunikaci server-client, která dnes představuje nejtěžší část webové aplikace.</p>
<h2>Pořád jen Facebook<a id="po-d-jen-facebook">&nbsp;</a></h2><p>Všechny výše uvedené projekty jsou široce používané a je kolem nich mohutná komunita. Nevezou se však na popularitě Reactu, protože s ním nejsou nijak spojené. Jsou prostě tak dobré. <strong>Facebook v posledních letech jednoznačně udává trendy v tvorbě webových aplikací</strong>. Nevytváří velké ucelené frameworky, ale pouze malé pragmatické knihovny s minimalistickým API, což má v JS ekosystému úspěch. Přístup Facebooku k opensource by měl být vzorem i pro další firmy.</p>
<p><strong>Druhým webovým hegemonem je Google</strong>, který ale v poslední době působí trochu schizofrenicky. Jakoby si každý jeho tým budoval vlastní framework/knihovnu a tak tu máme vedle sebe <a href="https://angularjs.org/">Angular</a>, <a href="https://developers.google.com/closure/">Closure Tools</a> a <a href="https://www.polymer-project.org/1.0/">Polymer</a>. Alespoň už zařízl Dart a třeba tak více konsoliduje své síly, co se JS knihoven týče.</p>
<h2>Server vs prohlížeč<a id="server-vs-prohl-e-">&nbsp;</a></h2><p>Klasické server-side webovky jsou vcelku jednoduché. <strong>Server totiž nemusí udržovat žádný stav</strong>. Přijde mu požadavek od uživatele, poslepuje dohromady nějaké řetězce (část z nich načte třeba z databáze) a celé to pak pošle uživateli do prohlížeče, který to rozparsuje a sestaví DOM (Document Object Model - stromová reprezetace toho co vidíte v prohlížeči jako HTML stránku + metody, kterými se dá upravovat či procházet).</p>
<p><strong>Interaktivní JS webovky, které běží v prohlížeči, jsou podstatně složitější</strong>. Chceme totiž po nich daleko více než od server-side aplikací. Chceme nabídnout daleko vyšší uživatelský zážitek. Je trochu zbytečné s každou akcí překreslovat celou stránku, když můžeme změny bleskově provádět pomocí funkcí DOMu a uživateli tak dopřát pohodlí, které zná z desktopových aplikací.</p>
<h2>Zlý DOM<a id="zl-dom">&nbsp;</a></h2><p><strong>DOM a JavaScript jsou dvě úplně rozdílné věci</strong>. Teoreticky by mohl být DOM upravován i jiným jazykem, ale v praxi prohlížeče nabízejí pouze JavaScript. DOM je obrovský moloch, práce s ním je pomalá a prohlížeče nejsou vždy jednotné v jeho implementaci. <strong>JavaScript pak často neprávem sklízí nenávistné komentáře, které by ale měly směřovat právě na DOM</strong>. Dnešní JavaScript je naopak velmi rychlý a vcelku lišácky navržený, což ostatně potvrzuje i to, že se rozšiřuje i do oblastí, kde má narozdíl od prohlížečů silnou konkurenci (node.js).</p>
<p>DOM navíc představuje jednu velkou globální proměnnou, což přímo svádí k tomu, abychom ho používali jako místo pro ukládání stavu naší aplikace. Asi nemusím popisovat proč jsou globální proměnné zlo. U DOMu to pak ještě zhoršuje jeho pomalost. <strong>Stav aplikace bychom tedy měli udržovat jinde - v našem JavaScriptu</strong> a do DOMu šahat, jenom když je to skutečně potřeba. Pouze do něj zrcadlit změny z našeho JS kódu. Jenže jak to jednoduše udělat?</p>
<h2>Přínos Reactu<a id="p-nos-reactu">&nbsp;</a></h2><p><strong>Nejzřejmější výhoda pro začátečníka je ta, že React nás prakticky úplně odstíní od DOMu</strong>. V React komponentách pouze deklarativně zadefinujeme strukturu (HTML) skládáním JS funkcí. Jinými slovy, popíšeme, jak má vypadat výsledná stránka na základě příchozích dat. React si z toho poskládá svůj vlastní virtuální DOM, který pak pomocí chytrých algoritmů porovnává s tím skutečným DOMem a když najde rozdíly, tak ho nejefektivnějším možným způsobem aktualizuje. <strong>My už pak jenom dodáváme nová data do jednotlivých komponent a tím pro nás veškerá práce končí</strong>. V prohlížeči vždy uvidíte aktuální pohled vzhledem k dodaným datům. Tohle je &quot;deal breaker&quot;, který vám pravděpodobně není úplně zřejmý, pokud už nemáte předešlou trpkou zkušenost s imperativním přístupem u větší aplikace, což je typicky jQuery a fidlování s jednotlivými DOM elementy.</p>
<h2>Začínáme<a id="za-n-me">&nbsp;</a></h2><p>Je načase si ukázat první příklad. Komponenty si budete moc vyzkoušet přímo v rámci této stránky nebo zkopírováním do svého <a href="prvni-dev-stack.html">vymazleného stacku</a>. Najdete je samozřejmě také v <a href="https://github.com/tajo/javascript/tree/master/examples/react">repozitáři</a>. Budu téměř výhradně používat novou čerstvě vydanou ES6 syntax.</p>
<p>Naše první komponenta se bude jmenovat <code>Counter</code> a <strong>bude udržovat a zobrazovat počet našich kliknutí</strong>. Hned se podívejte na výsledek:</p>
<p></div><div class="codeBlock" style="border-left:solid 5px rgba(44, 83, 158, 0.9);" data-reactid=".cjehldcdfk.1.0.1.0.0.$1"><div data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter"><span data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter.0">Kliknul jsi </span><span data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter.1">0</span><span data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter.2">x. </span><br data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter.3"><button data-reactid=".cjehldcdfk.1.0.1.0.0.$1.$counter.4">Klikni!</button></div><div style="font-size:0.8em;bottom:0;right:0;margin:5px;position:absolute;" data-reactid=".cjehldcdfk.1.0.1.0.0.$1.1"><a href="https://github.com/tajo/javascript/tree/master/examples/react/counter.js" data-reactid=".cjehldcdfk.1.0.1.0.0.$1.1.0">zdrojový kód</a></div></div><div style="width:100%;" data-reactid=".cjehldcdfk.1.0.1.0.0.$2"></p>
<p>A teď si to pojďme rozebrat a naprogramovat. Jak už to bývá, ani u Reactu se neobejdme bez minimálního boilerplate kódu:</p>
<code class="codeBlock"><span class="token keyword" >import</span> <span class="token qualifier" >React</span> from <span class="token string" >'react'</span><span class="token punctuation" >;</span>

<span class="token keyword" >export</span> <span class="token keyword" >default</span> <span class="token keyword" >class</span> <span class="token class-name" >Counter</span> <span class="token keyword" >extends</span> <span class="token class-name" >React<span class="token punctuation" >.</span>Component</span> <span class="token punctuation" >{</span></code><p><strong>Nikdy nesmíme zapomenout na importování Reactu</strong>. I když to není na první pohled zřejmé, tak ony HTML tagy (JSX) jsou ve skutečnosti převlečené funkce Reactu, ale to bychom teď předbíhali. Novou komponentu jednoduše oddědíme od <code>React.Component</code> a <code>export default class Counter</code> nám komponentu zpřístupní napříč celou aplikací.</p>
<p><strong>React komponenty mají pouze jednu povinnou metodu a to <code>render()</code></strong>. V ní se očekává, že popíšete strukturu komponenty včetně jejích závislostí na data. Metoda musí pak vrátit 1 root element (například <code>&lt;div/&gt;</code>), který už může mít libovolný počet potomků včetně dalších React komponent. Takhle vypadá ta naše:</p>
<code class="codeBlock"><span class="token function" >render<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
  <span class="token keyword" >return</span> <span class="token punctuation" >(</span>
    <span class="token operator" >&lt;</span>div<span class="token operator" >></span>
      <span class="token qualifier" >Kliknul</span> jsi <span class="token punctuation" >{</span><span class="token var" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>counter<span class="token punctuation" >}</span>x<span class="token punctuation" >.</span> <span class="token operator" >&lt;</span>br<span class="token operator" >/</span><span class="token operator" >></span>
      <span class="token operator" >&lt;</span>button onClick<span class="token operator" >=</span><span class="token punctuation" >{</span><span class="token punctuation" >(</span>e<span class="token punctuation" >)</span> <span class="token operator" >=</span><span class="token operator" >></span> <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span><span class="token punctuation" >}</span><span class="token operator" >></span>
        <span class="token qualifier" >Klikni</span><span class="token operator" >!</span>
      <span class="token operator" >&lt;</span><span class="token operator" >/</span>button<span class="token operator" >></span>
    <span class="token operator" >&lt;</span><span class="token operator" >/</span>div<span class="token operator" >></span>
  <span class="token punctuation" >)</span><span class="token punctuation" >;</span>
<span class="token punctuation" >}</span></code><p><strong>Povšimněte si, že &quot;uprostřed&quot; JSX zápisu můžete opět vkládat JS výrazy</strong>, pokud je obalíte do <code>{}</code> a takhle to můžete prokladát do několika úrovní, pokud máte rádi nepřehledný kód. JSX velmi připomíná klasické HTML a rozdílů byste našli jen několik. Což je vcelku zajímavé, protože pod pokličkou jde o principálně zcela jinou věc.</p>
<p><code>this.state</code> je jeden ze dvou hlavních objektů, který &quot;krmí&quot; React komponenty daty. O tom druhém <code>this.props</code> a rozdílech si povíme až příště. <strong><code>this.state</code> je lokální stav komponenty, do kterého si můžeme ukládat libovolná data</strong>. Nám se hodí pro uložení počtu kliknutí. Pomocí <code>{this.state.counter}</code> si tento počet pak jednoduše vypíšeme.</p>
<p>Klikací tlačítko má atribut <code>onClick</code>. <strong>Vzpomínáte na poučku, že se nemají používat tyto inline atributy pro volání JS? Tak ta stále platí.</strong> Nicméně protože <code>&lt;button/&gt;</code> je ve skutečnosti JS funkce a ne HTML element, tak i <code>onClick</code> nemá s tím klasickým moc společného.</p>
<p>React má totiž propracované delegování eventů a tak i když budete mít v aplikaci tisíc onClicků, tak z nich React udělá jenom jeden, který pověsí na root element a příchozí eventy nechá probublat k patřičným odběratelům. To velmi šetří výkon a vám nervy, pokud byste podobnou (a nutnou) optimalizaci museli sami implementovat. V Reactu tak můžete libovolně &quot;plýtvat&quot; s listenery jako <code>onKeyDown</code>, <code>onCopy</code>, <code>onFocus</code>, <code>onScroll</code> ... Je jich daleko <a href="https://facebook.github.io/react/docs/events.html">více</a>.</p>
<code class="codeBlock">onClick<span class="token operator" >=</span><span class="token punctuation" >{</span><span class="token punctuation" >(</span>e<span class="token punctuation" >)</span> <span class="token operator" >=</span><span class="token operator" >></span> <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span><span class="token punctuation" >}</span></code><p>Listener očekává funkci, kterou má zavolat, pokud dojde k dané události. <strong>Otázka za milion: Proč naši funkci <code>this.handleClick</code> ještě balíme do další funkce s fat arrow <code>=&gt;</code>?</strong> Protože potřebujeme v <code>handleClick</code> mít přístup k <code>this.state</code> a pokud bychom napsali</p>
<code class="codeBlock">onClick<span class="token operator" >=</span><span class="token punctuation" >{</span><span class="token var" >this</span><span class="token punctuation" >.</span>handleClick<span class="token punctuation" >}</span></code><p>tak se nám do funkce <code>handleClick</code> předá context DOM elementu, ve kterém se ale už nenachází náš <code>this.state.counter</code>. <strong>Proto musíme explicitně nastavit (bindnout) správný context React komponety ručně, což dělá právě ona fat arrow</strong>. Pokud jste zmatení z pojmů jako closure, scope nebo context, tak si <a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/">přečtěte tento článek</a>. Jde o fundamenty, které dělají JS tím čím je.</p>
<p>Kde se vlastně bere state neboli stav komponenty? Musíme ho nejprve inicializovat a to se nemůže dít nikde jinde než v konstruktoru:</p>
<code class="codeBlock"><span class="token function" >constructor<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
  <span class="token function" >super<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span><span class="token punctuation" >;</span>
  <span class="token var" >this</span><span class="token punctuation" >.</span>state <span class="token operator" >=</span> <span class="token punctuation" >{</span>counter<span class="token punctuation" >:</span> <span class="token number" >0</span><span class="token punctuation" >}</span><span class="token punctuation" >;</span>
<span class="token punctuation" >}</span></code><p>Zbývá si už jen napsat funkci, která se zavolá kliknutím na naše tlačítko:</p>
<code class="codeBlock"><span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
  <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >setState<span class="token punctuation" >(</span></span>previousState <span class="token operator" >=</span><span class="token operator" >></span> <span class="token punctuation" >{</span>
    <span class="token keyword" >return</span> <span class="token punctuation" >{</span>counter<span class="token punctuation" >:</span> previousState<span class="token punctuation" >.</span>counter <span class="token operator" >+</span> <span class="token number" >1</span><span class="token punctuation" >}</span><span class="token punctuation" >;</span>
  <span class="token punctuation" >}</span><span class="token punctuation" >)</span><span class="token punctuation" >;</span>
<span class="token punctuation" >}</span></code><p><strong>Stav komponenty se vždy a pouze mění pomocí metody <code>this.setState()</code></strong>. Vyvarujte se pokušení napsat <code>this.state =</code>, protože by se vám pak nezavolal <code>render()</code>. Do <code>setState</code> můžeme jako první argument předat přímo novou hodnotu stavu nebo funkci, do které dostaneme předchozí stav (a props), což se právě hodí pro inkrementování. Náš případ by šel zapsat i jako:</p>
<code class="codeBlock"><span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
  <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >setState<span class="token punctuation" >(</span></span><span class="token punctuation" >{</span>counter<span class="token punctuation" >:</span> <span class="token var" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>counter <span class="token operator" >+</span> <span class="token number" >1</span><span class="token punctuation" >}</span><span class="token punctuation" >)</span><span class="token punctuation" >;</span>
<span class="token punctuation" >}</span></code><p><strong>Kdy a jak probíhá překreslení?</strong> To už má plně v režii React. K zavolání metody <code>render()</code> dochází, pokud se změní <code>this.state</code> nebo <code>this.props</code>, případně, pokud zavoláme <code>forceUpdate()</code>. <strong>Metoda render vygeneruje nový virtuální DOM a porovná ho s tím skutečným v prohlížeči</strong>. Pokud najde nějaké změny, tak je nejefektivnějším způsobem aplikuje. Svižné a elegantní. Nikde jsme nemuseli definovat, jak, kdy a které DOM elementy je potřeba aktualizovat. <strong>Pouze jsme popsali strukturu a její vztah k datům.</strong></p>
<p>Výsledný kód:</p>
<code class="codeBlock"><span class="token keyword" >import</span> <span class="token qualifier" >React</span> from <span class="token string" >'react'</span><span class="token punctuation" >;</span>

<span class="token keyword" >export</span> <span class="token keyword" >default</span> <span class="token keyword" >class</span> <span class="token class-name" >Counter</span> <span class="token keyword" >extends</span> <span class="token class-name" >React<span class="token punctuation" >.</span>Component</span> <span class="token punctuation" >{</span>

  <span class="token function" >constructor<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
    <span class="token function" >super<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span><span class="token punctuation" >;</span>
    <span class="token var" >this</span><span class="token punctuation" >.</span>state <span class="token operator" >=</span> <span class="token punctuation" >{</span>counter<span class="token punctuation" >:</span> <span class="token number" >0</span><span class="token punctuation" >}</span><span class="token punctuation" >;</span>
  <span class="token punctuation" >}</span>

  <span class="token function" >render<span class="token punctuation" >(</span></span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
    <span class="token keyword" >return</span> <span class="token punctuation" >(</span>
      <span class="token operator" >&lt;</span>div<span class="token operator" >></span>
        <span class="token qualifier" >Kliknul</span> jsi <span class="token punctuation" >{</span><span class="token var" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>counter<span class="token punctuation" >}</span>x<span class="token punctuation" >.</span> <span class="token operator" >&lt;</span>br<span class="token operator" >/</span><span class="token operator" >></span>
        <span class="token operator" >&lt;</span>button onClick<span class="token operator" >=</span><span class="token punctuation" >{</span><span class="token punctuation" >(</span>e<span class="token punctuation" >)</span> <span class="token operator" >=</span><span class="token operator" >></span> <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span><span class="token punctuation" >}</span><span class="token operator" >></span>
          <span class="token qualifier" >Klikni</span><span class="token operator" >!</span>
        <span class="token operator" >&lt;</span><span class="token operator" >/</span>button<span class="token operator" >></span>
      <span class="token operator" >&lt;</span><span class="token operator" >/</span>div<span class="token operator" >></span>
    <span class="token punctuation" >)</span><span class="token punctuation" >;</span>
  <span class="token punctuation" >}</span>

  <span class="token function" >handleClick<span class="token punctuation" >(</span></span>e<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>
    <span class="token var" >this</span><span class="token punctuation" >.</span><span class="token function" >setState<span class="token punctuation" >(</span></span>previousState <span class="token operator" >=</span><span class="token operator" >></span> <span class="token punctuation" >{</span>
      <span class="token keyword" >return</span> <span class="token punctuation" >{</span>counter<span class="token punctuation" >:</span> previousState<span class="token punctuation" >.</span>counter <span class="token operator" >+</span> <span class="token number" >1</span><span class="token punctuation" >}</span><span class="token punctuation" >;</span>
    <span class="token punctuation" >}</span><span class="token punctuation" >)</span><span class="token punctuation" >;</span>
  <span class="token punctuation" >}</span>

<span class="token punctuation" >}</span></code><h2>Závěrem<a id="z-v-rem">&nbsp;</a></h2><p><strong>Představili jsme si React, jeho krátkou historii a související projekty</strong>. Jedním ze strašáků &quot;programování v prohlížeči&quot; je DOM, často chybně a neférově zaměňován s JavaScriptem. React nám mj. umožňuje téměř kompletní abstrakci od DOMu. Strukturu jednotlivých komponent zapisujeme (deklarujeme) skládáním React funkcí, kterým následně dodáváme data a tím pro nás práce končí. React toho nabízí samozřejmě daleko více. Nakousli jsme třeba i systém eventů. <strong>S Reactem je to tak trochu jako dobrým čajem nebo kafem</strong>. Zpočátku vám bude připadat divný a musíte se k němu postupně &quot;propít&quot;. Až poté se stane nepostradatelnou součástí vašeho programátorského dne.</p>
<p><strong>Příště si ukážeme, co jsou to <code>this.props</code> a jak se liší od <code>this.state</code></strong>. Také si více povíme o životním cyklu komponenty a jejích dalších metodách.</p>
</div></div></div></div><footer data-reactid=".cjehldcdfk.1.0.2"><div class="links" data-reactid=".cjehldcdfk.1.0.2.0"><div style="float:left;" data-reactid=".cjehldcdfk.1.0.2.0.0"><span data-reactid=".cjehldcdfk.1.0.2.0.0.0">◀</span><span data-reactid=".cjehldcdfk.1.0.2.0.0.1"> </span><a href="prvni-dev-stack.html" target="_self" data-reactid=".cjehldcdfk.1.0.2.0.0.2">První dev stack</a></div><div style="float:right;" data-reactid=".cjehldcdfk.1.0.2.0.1"><a href="react-props-vs-state.html" target="_self" data-reactid=".cjehldcdfk.1.0.2.0.1.0">React - Props vs State</a><span data-reactid=".cjehldcdfk.1.0.2.0.1.1"> </span><span data-reactid=".cjehldcdfk.1.0.2.0.1.2">▶</span></div></div><div class="Footer" data-reactid=".cjehldcdfk.1.0.2.1"><span data-reactid=".cjehldcdfk.1.0.2.1.0">Diskutujte prostřednictvím </span><a href="https://github.com/tajo/javascript/issues" data-reactid=".cjehldcdfk.1.0.2.1.1">issues</a><span data-reactid=".cjehldcdfk.1.0.2.1.2">.</span><br data-reactid=".cjehldcdfk.1.0.2.1.3"><span data-reactid=".cjehldcdfk.1.0.2.1.4">Vylepšete článek </span><a href="https://github.com/tajo/javascript/pulls" data-reactid=".cjehldcdfk.1.0.2.1.5">pull requestem</a><span data-reactid=".cjehldcdfk.1.0.2.1.6">.</span><br data-reactid=".cjehldcdfk.1.0.2.1.7"><span data-reactid=".cjehldcdfk.1.0.2.1.8">Sledujte na </span><a href="https://twitter.com/vmiksu" data-reactid=".cjehldcdfk.1.0.2.1.9">twitteru</a><span data-reactid=".cjehldcdfk.1.0.2.1.a">. </span><span data-reactid=".cjehldcdfk.1.0.2.1.b"> </span><a href="/feed.xml" data-reactid=".cjehldcdfk.1.0.2.1.c">RSS</a><span data-reactid=".cjehldcdfk.1.0.2.1.d">.</span><br data-reactid=".cjehldcdfk.1.0.2.1.e"><span data-reactid=".cjehldcdfk.1.0.2.1.f">Inspirováno </span><a href="https://github.com/este/este" data-reactid=".cjehldcdfk.1.0.2.1.g">Este</a><span data-reactid=".cjehldcdfk.1.0.2.1.h">.</span><br data-reactid=".cjehldcdfk.1.0.2.1.i"><b data-reactid=".cjehldcdfk.1.0.2.1.j">Sdílejte!</b></div></footer></div><script data-reactid=".cjehldcdfk.1.1">window.INITIAL_PROPS = {"location":"react-uvod.html","devMode":false,"files":{"main.css":"main-c4e5492e99c449d90c84.css","main.js":"main-c4e5492e99c449d90c84.js"}};
</script><script src="main-c4e5492e99c449d90c84.js" data-reactid=".cjehldcdfk.1.2"></script><div data-reactid=".cjehldcdfk.1.3">
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-63660429-1', 'auto');
          ga('send', 'pageview');
        </script>
      </div></body></html>